[
["index.html", "Pseudo Random Number Generators in R 1 Motivation and Background 1.1 Random Numbers! 1.2 Types of Random Number Generators", " Pseudo Random Number Generators in R 1 Motivation and Background 1.1 Random Numbers! What does it mean for a number to be “random”? Well, nothing actually, since any number on its own can be considered random. What I will be discussing in this tutorial is the concept of random sequences of numbers. Well what does it mean for a sequence of numbers to be random? In short it means you have no idea of what number will come next in the sequence; there are no patterns. We will look more closely on how to judge what makes one sequences more random than another later. Being able to produce random sequences of numbers is not just a cool trick but has important practical applications. Areas like weather simulation, physics simulations, cryptography, simulating games with probabilities, all rely on a proper way to represent a random chance of an event happening. In R any time you use a function like runif() it needs to create a “random” distribution of numbers that follow a uniform distribution. These are a few examples among the many of the importance of random number sequences. 1.2 Types of Random Number Generators Before we dive into the code, an important distinction to make is the difference between true random number generator and pseudo random number generator (PRNG). A true random number generator is one that utilizes some external input that we believe is random to create the sequence of numbers. Examples of these include using a Geiger counter to measure background radiation, measuring static from a TV, or even measuring the electron noise measured by a smartphone camera. For more information about those, check out this nice Wikipedia article. The disadvantage to using these hardware random number generators, is that they are not very fast (at generating the sequence) and they are not reproducable. Plus, they require the extra hardware. Most of the time we don’t need this “true” randomness and we can get away with a pseudo random number generator. A PRNG is just an algorithm that, when given some initial conditions, produces a sequence of random looking numbers. They are pseudo-random because that sequence will eventually repeat itself. Most often in computer programming languages you will use something called a “seed” which sets the initial conditions of the algorithm. Then, using the same seed, you can successfully reproduce your pseudo-random sequence. The rest of this tutorial will be focused on how these PRNGs are implemented and what makes one algorithim better than another statistically. "],
["middle-square.html", "2 Middle-Square", " 2 Middle-Square The first PRNG algorithm we’ll look at is one of the very first to be popularized (1949) and was credited to John von Neumann. The implementation for an n-digit number sequence is as follows Take a starting seed number and square it If the result has fewer than 2n digits, leading zeroes are added to compensate The middle n digits of the result become the next number And that’s it! Here is an implementation in r: middle_square &lt;- function(seed){ n &lt;- 4 result &lt;- toString(seed^2) while (nchar(result) &lt; n * 2){ result &lt;- paste0(&quot;0&quot;, result) } return(as.numeric(substr(result, 3, 6))) } Lets take a look at it in R and see what kind of random sequences it produces. Our generator will take in a 4 digit number as the seed seed &lt;- 2341 results &lt;- seed for (i in 1:1000) { seed &lt;- middle_square(seed) results &lt;- c(results, seed) } Histogram of our results to see the distribution of numbers library(tidyverse) ggplot() + geom_histogram(aes(results)) OOF what happened? We started off good, but then hit a point which had a very small peroid. This means it repeats itself very quickly. As we can see from the histogram, we ran into a point which had a peroid of 4 and it kept looping between those numbers. "],
["linear-congruential-generator.html", "3 Linear congruential generator", " 3 Linear congruential generator We clearly need a better PRNG than middle-square if we want to have any hope of simulating random events. Luckily there have been many new ideas since 1949. Today, the most widely used general purpose PRNG is called the Mersenne Twister. It was developed in 1997 by Makoto Matsumoto Takuji Nishimura to overcome the flaws of the old PRNGs. This particular algorithm is used as the default PRNG in python, r, c++, and many more programming languages. The Mersenne Twister is based of of a simpler algorithm called a “Linear congruential generator” which we will look at The algorithim takes in 4 inputs (as opposed to just the 1 that middle-square did). the inputs are : - m the modulus - a the multiplier - c the increment - X_0 the seed LCG &lt;- function(m, a, c, X_0){ return((a * X_0 + c) %% m) } With this method, we want to pick a large value for m, such as 2^32 m &lt;- 2^32 a &lt;- 123 c &lt;- 4298 X_0 &lt;- 3123 LCG(m, a, c, X_0) ## [1] 388427 lets look at a distribution and plot it results &lt;- X_0 for (i in 1:1000) { X_0 &lt;- LCG(m, a, c, X_0) results &lt;- c(results, X_0) } ggplot() + geom_histogram(aes(results)) Wow, much better than the middle square. Notice how there isn’t an obvious pattern that got repeated. This means that this algorithm has a much higher period, which is one of the main ways to determine how “good” as PRNG is. "],
["lagged-fibonacci-generator.html", "4 Lagged Fibonacci generator", " 4 Lagged Fibonacci generator Another cool PRNG that is supposed to be an improvement on the LCG is called the Lagged Fibonacci generator. As its name suggests, it is based on the Fibonacci sequence. The inputs are: m the modulus j a starting number (seed) k another starting number &gt; j (seed) To get the next number in the sequence, go back j numbers in the sequence, and go back k numbers in the sequence, add those numbers, and then mod m. In code it looks like this: k = 13 j = 5 m = 2^4 LFG &lt;- function(n, m, j, k){ if(n &lt;= 1) { return(n) } else { return(LFG(n-k, m, j, k) + LFG(n-j, m, j, k) %% m) } } results &lt;- c() for (i in 1:100) { x &lt;- LFG(i, m, j, k) results &lt;- c(results, x) } ggplot() + geom_histogram(aes(results)) Note I’m generating less numbers this time because this algorithm takes longer to run. "],
["creating-other-distributions.html", "5 Creating other distributions", " 5 Creating other distributions As you might have noticed, these random number generators only give us uniform distributions of integers. Usually we like to get our random number between 0 and 1, so we can just divide our sequence by the max integer it can produce, no problem. But what if we want to generate another distribution like a normal or exponential? We, use something called inverse transform sampling. As long as we have the Cumulative distribution function for the distribution we are looking for, we can transform it. We take our numbers between 0 and 1, and then find what values of the CDF would output those uniform values. "]
]
